import numpy as np

C= np.array([[0],[-1],[-1],[-1],[-1],[-1],[-1],[-1],[-1],[-1],[-1],[-1],[-1],[-1],[-1],[0]])
P1=np.zeros((16,16))
P2=np.zeros((16,16))
P3 = np.zeros((16,16))
P4 = np.zeros((16,16))

#状态1处的转移
P1[1,2]=1
P2[1,5]=1
P3[1,0]=1
P4[1,1]=1
#状态2处的转移
P1[2,3]=1
P2[2,6]=1
P3[2,1]=1
P4[2,2]=1
#状态3处的转移
P1[3,3]=1
P2[3,7]=1
P3[3,2]=1
P4[3,3]=1
#状态4处的转移
P1[4,5]=1
P2[4,8]=1
P3[4,4]=1
P4[4,0]=1
#状态5处的转移
P1[5,6]=1
P2[5,9]=1
P3[5,4]=1
P4[5,1]=1
#状态6处的转移
P1[6,7]=1
P2[6,10]=1
P3[6,5]=1
P4[6,2]=1
#状态7处的转移
P1[7,7]=1
P2[7,11]=1
P3[7,6]=1
P4[7,3]=1
#状态8处的转移
P1[8,9]=1
P2[8,12]=1
P3[8,8]=1
P4[8,4]=1
#状态9处的转移
P1[9,10]=1
P2[9,13]=1
P3[9,8]=1
P4[9,5]=1
#状态10处的转移
P1[10,11]=1
P2[10,14]=1
P3[10,9]=1
P4[10,6]=1
#状态11处的转移
P1[11,11]=1
P2[11,15]=1
P3[11,10]=1
P4[11,7]=1
#状态12处的转移
P1[12,13]=1
P2[12,12]=1
P3[12,12]=1
P4[12,8]=1
#状态13处的转移
P1[13,14]=1
P2[13,13]=1
P3[13,12]=1
P4[13,9]=1
#状态14处的转移
P1[14,15]=1
P2[14,14]=1
P3[14,13]=1
P4[14,10]=1
#策略Pi
Pi = np.array([0.25])
print(0.25*P1+0.25*P2+0.25*P3+0.25*P4)
P_pi = 0.25*P1+0.25*P2+0.25*P3+0.25*P4

M = np.eye(16)-P_pi
I_M = np.linalg.inv(M)
print(np.dot(I_M,C))

#初始化当前值函数
V_cur= np.zeros((16,1))
V_next = C+np.dot(P_pi,V_cur)
#计算迭代一次的误差
delta = np.linalg.norm(V_next-V_cur)
num=0
while delta>1e-2:
    V_cur = V_next
    V_next = C+np.dot(P_pi,V_cur)
    delta = np.linalg.norm(V_next-V_cur)
    num=num+1
print(V_cur,num)